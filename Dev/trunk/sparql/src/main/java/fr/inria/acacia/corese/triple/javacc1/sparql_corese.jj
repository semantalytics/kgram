// Author: Virginie BOTTOLLIER & Olivier Corby
// 07/11/2005
// This version of the grammar is for SPARQL 1.1 select expression wich needs ()
// select (fun(?x) as ?y) where
// the difference starts at BEGIN SPARQL1.1

options
{
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false ;
  STATIC = false ;
  COMMON_TOKEN_ACTION = true;
// Do \ u processing outside javacc
// JAVA_UNICODE_ESCAPE   = false ;
// UNICODE_INPUT         = true ;
// DEBUG_PARSER          = true ;	// set to true to see calls to functions
// DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(SparqlCorese)
  
  	package fr.inria.acacia.corese.triple.javacc1;

	import org.apache.log4j.Logger;
	
	import java.util.ArrayList;
	import java.util.Vector;
  	import fr.inria.acacia.corese.triple.cst.RDFS;
  	import fr.inria.acacia.corese.triple.parser.*;
  	import fr.inria.acacia.corese.triple.update.*;
  	
  
  /**
  * <p>Title: Corese</p>
  * <p>Description: A Semantic Search Engine</p>
  * <p>Copyright: Copyright INRIA (c) 2006</p>
  * <p>Company: INRIA</p>
  * <p>Project: Acacia</p>
  * <br>
  * This file defines the SPARQL/Corese grammar; it's from it, that we create 
  * the 7 others classes, thanks to the JavaCC technology.
  * <br>
  * @author Virginie Bottollier
  */
  public class SparqlCorese {
  
    /** An instanciation of the class Parser */
    //Parser parser;
    /** An instanciation of the class ASTQuery (a graph representing the query) */
    ASTQuery astq, gast;
    ASTUpdate astu;
    /** should we say to the user when he uses something deprecated? (option, sort, or, source, as...) */
    boolean printDeprecated = true;
	
	/** logger from log4j */
	private static Logger logger = Logger.getLogger(SparqlCorese.class);
	
    /** To show some printings */
    boolean show = false;
    /** To show some printings about the part of the parser which deals with Expression */
    boolean debug2 = show && false;
    
	public void setASTQuery(ASTQuery aq) {
		astq = aq;
		gast = aq;
	}
	
	/**
	* @param s1 = the string deprecated
	* @param s2 = how to replace s1
	*/
	public void deprecated(String s1, String s2) {
		if (printDeprecated) {
			logger.debug("*** \""+s1+"\" is deprecated, you should use \""+s2+"\" instead");
		}
	}
    
    /**
     * @throws JavaccParseException
     * @throws TokenMgrError
     * @return
     */
    public ASTQuery parse() throws JavaccParseException, TokenMgrError {
        Exp ex;
        astu = ASTUpdate.create();
        try {
        if (astq.isRule()) ex = Rule();
        	else ex = Start();
        } catch(ParseException e) {
        	throw new JavaccParseException(e);
        }
        if (show)
        	for (int i = 0; i<ex.size();i++) {
        		logger.debug("sparql-parser - ex.get("+i+"): "+ex.get(i));
        	} 
        if (astq.isSelected(ex)) {	// true if get:gui ok
        	astq.setSelect();	        
        } else {
        	//ex = null; // Do not do this, because we want to keep triples that are ok
        }
        astq.setBody(ex);
        return astq;
    }    
  }
  
PARSER_END(SparqlCorese)

Exp Start(): { Exp stack; }
{
	{ stack = new And(); }
  	 stack = Query()  <EOF> 
  	{ return stack; }
}

Exp Rule(): { Exp stack; }
{
	{ stack = new And(); }
	Prolog()
  	 stack = GroupGraphPattern()  <EOF> 
  	{ return stack; }
}

Exp Query() : { Exp stack; }
{

	{stack = BasicGraphPattern.create();}
	
  Prolog()
  
  ( 
  	  stack = SelectQuery()
  	| stack = ConstructQuery() 
  	| stack = DescribeQuery() 
  	| stack = AskQuery() 
  	| UpdateQuery() 	   
  	{
  		astq.setResultForm(ASTQuery.QT_UPDATE);
  		astq.set(astu);
  	}
  	
  ) ?
  
  { return stack; }
}


void Prolog() : {}
{
	( BaseDecl() ) ?
  	( PrefixDecl() )*
}

void BaseDecl() : { Token t; String s; Triple triple; }
{
  t = <BASE> s = Q_IRI_ref()
  {
	astq.defBase(s);
  }
}

void PrefixDecl() : { Token t1, t2; String s; Triple triple; }
{
  t1 = <PREFIX> t2 = <QNAME_NS> s = Q_IRI_ref()
  {
 	astq.defNamespace(t2.image, s);
  }   
}




// *******************************************************************
 
// Update

void  UpdateQuery() : { Exp stack; }
{
	UpdateQuery1()
	
	( <SEMICOLON> ( Prolog() UpdateQuery() ) ? ) ?
}




void UpdateQuery1() : { 
	Exp stack; Basic ope;
	Constant graph, uri, target; 
	boolean silent, defaut, named, all;
	}
{

	{
		stack = BasicGraphPattern.create();
		graph = null; uri = null; target = null;
		silent = false;
		defaut = false;
		all = false;
		ope = null;
	}
	
	(
		<LOAD> {ope = Basic.create(Update.LOAD);} 
		(<SILENT> 	{ope.setSilent(true);} ) ?  
		uri = IRIrefConst() {ope.setURI(uri);} 
		( <INTO> <GRAPH> graph = IRIrefConst() {ope.setTarget(graph);} ) ?
	|
		(<CLEAR>  	{ope = Basic.create(Update.CLEAR);} | <DROP> {ope = Basic.create(Update.DROP);})
		
		(<SILENT> 	{ope.setSilent(true);} ) ?  
			
		(<GRAPH> 	graph = IRIrefConst() {ope.setGraph(graph);} | 
		
		<DEFAUT> 	{ope.setDefault(true);} | 
		<NAMED> 	{ope.setNamed(true);} |
		<ALL> 		{ope.setAll(true);})

		
	|
		<CREATE> {ope = Basic.create(Update.CREATE);} (<SILENT> {ope.setSilent(true);} ) ?  
		<GRAPH> graph = IRIrefConst() {ope.setGraph(graph);}
	|
		(<ADD>  {ope = Basic.create(Update.ADD);}  | 
		 <MOVE> {ope = Basic.create(Update.MOVE);} | 
		 <COPY> {ope = Basic.create(Update.COPY);})
		
		(<SILENT> {ope.setSilent(true);} ) ?
		   
		(<GRAPH> graph = IRIrefConst()  {ope.setGraph(graph);}    | <DEFAUT> 	{ope.setDefault(true);} )  
		<TO>
		(<GRAPH> graph = IRIrefConst() {ope.setTarget(graph);}    | <DEFAUT> 	{ope.setDefault(true);} ) 
	
	|	
		LOOKAHEAD(2)
		DeleteInsertData()	
	|	
		DeleteInsertWhere()
	)
	
	{
		if (ope!=null) astu.add(ope);
	}

}



void DeleteInsertData() : {Exp exp; Composite ope, upd;}
{
	
	(
		<INSERT> <DATA>    exp = QuadPattern() 
		
		{ope = Composite.create(Update.INSERT, exp); }
	
	|
	
		<DELETE> 
		(
			<DATA>     exp =   QuadPattern() 
			
			{ope = Composite.create(Update.DELETE, exp);}
			
			|
			<WHERE>    exp = QuadPattern()
			
			{
				upd = Composite.create(Update.COMPOSITE); upd.setBody(exp); 
				ope = Composite.create(Update.DELETE);    ope.setPattern(exp); 
				upd.add(ope);
				ope = upd;
			}
			
		)
	)
	
	{ astu.add(ope); }

}




// create an AST as a whole

void DeleteInsertWhere() : {Exp exp; Composite upd, ope; Constant uri;}
{
	{upd = Composite.create(Update.COMPOSITE);}
	
	( <WITH> uri = IRIrefConst() 
	
	{upd.setWith(uri);}
	
	) ?
	
	(
		<DELETE> exp = QuadPattern() 			
		
		{ope = Composite.create(Update.DELETE); ope.setPattern(exp); upd.add(ope);}
		
		
		( <INSERT> exp = QuadPattern() 
		
		  {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
		) ?
		
		|
		
		<INSERT> exp = QuadPattern()
		
	    {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
	)
	
	// from & from named
	
	( <USING> (           uri = IRIrefConst()   { upd.addUsing(uri); } | 
	
	            <NAMED>   uri = IRIrefConst()   { upd.addNamed(uri); }
	          ) 
	) *
	
	<WHERE> exp = GroupGraphPattern()
	
	{ upd.setBody(exp); astu.add(upd); }

}




Exp QuadPattern() : {Exp stack;}
{
	{stack = BasicGraphPattern.create();}
	
	<LBRACE>
	
		( BlockOfTriples(stack) ) ?
			
		( GraphGraphPattern(stack)  ( BlockOfTriples(stack) ) ? ) *
	
	<RBRACE>
	
	{
	    return stack; 
	}

}




// *********************** End Update ********************************************************





// ---- Query type clauses

Exp SelectQuery() : { Exp stack; }
{

    <SELECT>
    Debug()
    (<NOSORT> {astq.setSorted(false); } )?
    OneMoreListMerge()
    GroupCountSortDisplayVar()
    Max()
    ( DatasetClause() )*
  stack = WhereClause()
  SolutionModifier()  
  {
    astq.setResultForm(ASTQuery.QT_SELECT);
    return stack; 
  }
}


void Debug(): {} 
{
 (<DEBUG> { astq.setDebug(true); } )?
 (<CHECK> { astq.setCheck(true); } )?
}



Exp ConstructQuery() : { Exp stack1, stack2; }
{
  (<CONSTRUCT> 
  //| <ADD>  {astq.setAdd(true);} 
  )
  Debug()
  
  (
  (
  // with a construct pattern
  stack1 = ConstructTemplate()
  // corese extension kept for compatibility
  (<SELECT> (SelectVar()) ?) ?    
  ( DatasetClause() )*
  stack2 = WhereClause()
  SolutionModifier()
  
  {	astq.setConstruct(stack1); 	return stack2; }
  )
  
  |
  
  (
  // without a construct pattern
  ( DatasetClause() )*
  <WHERE> stack2 =  ConstructTemplate2()
  SolutionModifier()
  
  {	astq.duplicateConstruct(stack2); 	return stack2; }
  )
  )
  
  
  
  
  
  
}

Exp DescribeQuery() : { Exp stack; Variable v; String s; Atom at;}
{  
  { stack = new And(); }	
  <DESCRIBE>
  Debug()
  ( 
  	( LOOKAHEAD(2) 
  		( 
  			  at = Var() { astq.setDescribe(at); }
  			| at = IRIrefConst() { astq.setDescribe(at); }
  		) 
  	)+
  	| <STAR> { astq.setDescribeAll(true); }
  )
  ( LOOKAHEAD(2) DatasetClause() )*
  ( LOOKAHEAD(2) stack = WhereClause() )?
  SolutionModifier()  
  { 
    astq.setResultForm(ASTQuery.QT_DESCRIBE);
  	return stack; 
  }
}

Exp AskQuery() : { Exp stack; }
{
  <ASK>
  Debug()
  ( DatasetClause() )*
  stack = WhereClause()
  (Bindings()) ?
  
  {
  	astq.setResultForm(ASTQuery.QT_ASK);
  	return stack;
  }
}

Exp DeleteQuery() : { Exp stack; }
{ 
	<DELETE>
	<STAR>
	stack = WhereClause()
	{ 
		astq.setDelete(true);
		astq.setResultForm(ASTQuery.QT_DELETE);
		return stack; 
	}
}

// ----

// one more list merge in any order and without list and merge being together
void OneMoreListMerge(): {}
{
  One() ( More() ( List() | Merge() )? | List() ( More() )? | Merge() ( More() )? )?
  | More() ( One() ( List() | Merge() )? | List() ( One() )? | Merge() ( One() )? )?
  | ( ( List() | Merge() ) ( One() ( More() )? | More() ( One() )? )? )?
}

void One(): {}
{
  <ONE>
  { astq.setOne(true); }
}

void More(): {}
{
  <S_MORE>
  { astq.setMore(true); }
}

void List(): {}
{
  <LIST>
  { astq.setList(true); }
}

void Merge(): {}
{
  <MERGE>
  { astq.setMerge(true); }
}

void GroupCountSortDisplayVar(): {}
{
  GroupCountSortDisplay() 
  ( 
  	(<DISTINCT> { astq.setDistinct(true);  } | <REDUCED> { astq.setReduced(true);  } ) 
  	( <SORTED> { astq.setStrictDistinct(false); } )?
  )? 
  ( 
  	SelectVar() 
  	GroupCountSortDisplay() 
  )?
}

// ***************** BEGIN SPARQL1.1

void SelectVar(): { Variable e1; Expression e2; Exp stack; } 
{

	{ stack = BasicGraphPattern.create(); }
	(
		( 
			( 
			LOOKAHEAD(2) 
			e1 = Var() { astq.defSelect(e1, null); } 
				| SelectExp(stack) ) 
		)+
  		| 
  		( 
  			<STAR> { astq.setSelectAll(true); } 
			( 
			SelectExp(stack) )*
 	  	)
	)
}


void SelectExp(Exp stack):{}
{	
	 <LPAREN> FunVar(stack) <RPAREN> 
}


void FunVar(Exp stack): { Expression e2; Variable e1; Variable var;} {
	
		 e2 = Expression(stack)
	
		
	<AS> ( 
			         var = Var() { astq.defSelect(var, e2); } 
			|
			
			// select sql("select a b from table") as (?x, ?y) where
			
			{ var = astq.newBlankNode(); 
				//astq.defSelect(var);
			}
			       
			<LPAREN> 
			              e1 = Var()  
			              { astq.addVariable(var, e1); 			          
			              } 
			              
				( <COMMA> e1 = Var()  
						  { astq.addVariable(var, e1); 
						  } 
			 	) *
				
			<RPAREN>
			
			{ astq.defSelect(var, e2);}       
		 )
}

// ********************* END SPARQL 1.1


void GroupCountSortDisplay(): {}
{
  ( LOOKAHEAD(2) (
    Group()
    //| Count()
    | Sort() 
    | Display() 
  ) )*  
}

void Group(): { Atom var; }
{
  <GROUP> (<BY>)?
  var = Var()
  { astq.setGroup(var.getName()); }
}

void Count(): { Atom var; }
{
  <COUNT> var = Var()
  { astq.setCount(var.getName()); }
}

void Sort(): { boolean reverse; Token t; Variable v; String sortby; Expression a; Term tm; Exp stack; }
{
  { reverse = false; stack = new And(); deprecated("sort", "order by"); }
  <SORT> 
  (
  	(<REVERSE> { reverse = true; } )? 
  	( 
  	  v = Var() { astq.setSort(v, reverse); }
  	  | a = BuiltInCall(stack) { astq.setSort(a, reverse); }
  	  | a = BrackettedExpression(stack) { astq.setSort(a, reverse); }
  	  | tm = FunctionCall(stack) { astq.setSort(tm, reverse); }
  	  | LOOKAHEAD(2) tm = FunctionCorese(stack) { astq.setSort(tm, reverse); }
	  | t = <COUNT> { sortby = t.image.toLowerCase(); astq.setSort(sortby, reverse); }
  	  | t = <DISTANCE> { sortby = t.image.toLowerCase(); astq.setSort(sortby, reverse); }       
	)
  )  
}

void Display(): { Token t; }
{
  <DISPLAY> ( 
  			  <D_RDF>  { astq.setRDF(true); }
  			| <D_JSON> { astq.setJSON(true); }  
  			| <D_FLAT> { astq.setFlat(true); }
  			| <D_ASQUERY> { astq.setPQuery(true); }
  			| ( t = <INTEGER> { astq.setMaxDisplay(Integer.parseInt(t.image)); } 
  			  )	
  			| <D_XML> { astq.setXMLBind(true); }
  			| <D_BLANK> { astq.setDisplayBNID(true); } 
  			)
}

void Max(): {}
{
  Projection() ( ( Result() ( Threshold() )? ) | ( Threshold() ( Result() )? ) )?
  | Result() ( ( Projection() ( Threshold() )? ) | ( Threshold() ( Projection() )? ) )? 
  | ( Threshold() ( ( Projection() ( Result() )? ) | ( Result() ( Projection() )? ) )? )?
}

void Projection(): { Token t; }
{
  <PROJECTION> 
  ( t = <INTEGER>
  { astq.setMaxProjection(Integer.parseInt(t.image)); }
  )
}

void Result(): { Token t; }
{
  <RESULT> 
  ( t = <INTEGER>
  { astq.setMaxResult(Integer.parseInt(t.image)); }
  )
}

void Threshold(): { Token t; }
{
  <THRESHOLD> 
  ( t = <INTEGER>
  { astq.setThreshold(Float.parseFloat(t.image)); }
   )
}



// ----

void DatasetClause() : { String s; }
{
  <FROM>
  ( s = DefaultGraphClause() { astq.setFrom(s); }
  | s = NamedGraphClause() { astq.setNamed(s); } )
}

String DefaultGraphClause() : { String s; }
{
  s = SourceSelector()
  { return s; }
}

String NamedGraphClause() : { String s; }
{
  <NAMED>
  s = SourceSelector()
  { return s; }
}

String SourceSelector() : {Token t1; String s; }
{
  (( s = IRIref() ) | ( t1 = <VAR1> { s = t1.image; } ))
  { return s; }
}

Exp WhereClause() : { Exp stack; }
{
   (<WHERE> { astq.setWhere(true); } )? 
   //{ stack = BasicGraphPattern.create(); }
   stack = GroupGraphPattern()
   { return stack; }
}

void SolutionModifier() : {}
{
   (Relax()) ?  
   (OrderGroup()) ? ( LimitOffset()) ? 
   (Bindings()) ?
   (Display()) * 
   (Pragma()) *
}


void Bindings() : {Variable var; Constant val; ArrayList<Variable> list; ArrayList<Constant>  value;}
{
	{list = new ArrayList<Variable>();}

	<BINDINGS> (var = Var() {list.add(var); }) *
				{ astq.setVariableBindings(list); }
	<LBRACE> 
	(
		<LPAREN> 
			{ value = new ArrayList<Constant>(); }
			( val = Value() { value.add(val); } ) * 
			{ astq.setValueBindings(value); }
		<RPAREN>
	)*
	<RBRACE>
}


Constant Value() : { Constant cst; String s; Token t1;}
{
  	( 
  	  s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME>    { cst = astq.createQName(t1.image);  }
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image);  }
  	| t1 = <UNDEF>    { cst = null; }  
  	| cst = RDFLiteral() 
  	| cst = NumericLiteral()
  	| cst = BooleanLiteral()   
  	) 
  	
  { return cst; }
}




void Pragma() : {Exp exp; String uri;}
{
	{uri = null;}
	<PRAGMA> (uri = IRIref()) ?  exp = GroupGraphPattern() 
	{
	astq.setPragma(uri, exp);
	}
	  
}


void Relax() : {Token t1; }
{
	<RELAX> <BY> t1 = <QNAME> 
	{astq.setDistance(t1.image);
	 } 
}


void LimitOffset() : {}
{
	ProjLimitClause()  ( OffsetClause() )? |
	OffsetClause() ( ProjLimitClause() )?

}

void OrderGroup() : {}
{
	GroupClause() (OrderClause())? (Having())? |
	OrderClause() (GroupClause())? (Having())? |
	Having()
}

void GroupClause(): { Variable var; Expression exp; Exp stack;}
{
 	{ 
  		stack = new And();
  		var = null;
  	}
  	
  	 <GROUP> <BY>
  (
  
  (
  	( 
  	//exp = BrackettedExpression(stack) |
  	
  	  <LPAREN> exp = Expression(stack) (<AS> var = Var() ) ? <RPAREN> |
  	  exp = Var() |
  	  exp = BuiltInCall(stack) |
  	  exp = FunctionCall(stack) |
  	  exp = FunctionCorese(stack)
  	)
  	{ astq.setGroup(exp, var); }
  ) + 
  	
  	|
  	
  <ANY> { astq.setConnex(true); }
  )
}




void Having() : {Exp stack; }
{
	{stack = new And();}
	
  	<HAVING> Filter(stack)
  	
  	{astq.setHaving(stack);}
  
}

void OrderClause() : {}
{
  <ORDER> <BY> 
  ( LOOKAHEAD(2) OrderCondition() )+
}

void OrderCondition() : { boolean reverse; Token t; String sortby; Variable v; Expression a; Term tm; Exp stack; }
{
  	{ 
  		reverse = false; 
  		stack = new And();
  	}
	( 
		v = Var() { astq.setSort(v, reverse); }
	    | a = BuiltInCall(stack) { astq.setSort(a, reverse); }
	    | tm = FunctionCall(stack) { astq.setSort(tm, reverse); }
	    | LOOKAHEAD(2) tm = FunctionCorese(stack) { astq.setSort(tm, reverse); }
		|
    	( 
    		( <ASC> | <DESC> { reverse = true; } )? 
    		( 
    			a = BrackettedExpression(stack) { astq.setSort(a, reverse); }
    			| t = <DISTANCE> { sortby = t.image; astq.setSort(sortby, reverse); }
    			| t = <COUNT> { sortby = t.image; astq.setSort(sortby, reverse); }
    		)
    	)    		
  	)  	
}

void ProjLimitClause() : { Token t; }
{
	Projection() ( LimitClause() ) ? | 
	LimitClause()
}

void LimitClause() : { Token t; }
{
  <LIMIT> 
  t = <INTEGER>
  { astq.setMaxResult(Integer.parseInt(t.image)); }
}

void OffsetClause() : { Token t; }
{
  <OFFSET> 
  t = <INTEGER>
  { astq.setOffset(Integer.parseInt(t.image)); }
}



// **** General Graph Pattern ********************************************



Exp GroupGraphPattern() : {Exp stack;}
{
  { stack = BasicGraphPattern.create(); }
  <LBRACE>  
    (   
  	  SubQuery(stack) |
  	  GraphPattern(stack) 
  	)
  <RBRACE>
  { return stack; }
}
 

void GraphPattern(Exp stack) : {}
{    
	FilteredBasicGraphPattern(stack)
  	(
	GraphPatternNotTriples(stack) 
    (<DOT>)?
    GraphPattern(stack)
  )?  	 
}


void FilteredBasicGraphPattern(Exp stack) : {} 
{	( BlockOfTriples(stack) )? 
	( 
		Constraint(stack) 
    	( <DOT> )? 
		FilteredBasicGraphPattern(stack) 		
	)?
}

//BlockOfTriples		:= TriplesSameSubject ( <DOT> ( TriplesSameSubject )? )*
void BlockOfTriples(Exp stack) : {}
{
	TriplesSameSubject(stack) 
	(		
		<DOT>
		|
		TriplesSameSubject(stack)
	)*
}

void GraphPatternNotTriples(Exp stack) : {ASTQuery ast;}
{
      OptionalGraphPattern(stack)
    | MinusGraphPattern(stack)
 	| LOOKAHEAD (2) GroupOrUnionGraphPattern(stack) 
 	| GraphGraphPattern(stack)
 	| ServicePattern(stack)
 	| ScoreGraphPattern(stack)
 	| ScopeGraphPattern(stack)
 	| NegationGraphPattern(stack)
 	| ForallGraphPattern(stack)
 	| IfThenElse(stack)
 	| ExistGraphPattern(stack)
 	| <LBRACE> SubQuery(stack) <RBRACE>
 	| Bind(stack) 
}

void SubQuery(Exp stack) : {ASTQuery ast; Query q; Exp exp;}
{
// 	  <LBRACE> 
		{ ast = astq; astq = gast.subCreate(); } 
 	  	exp = SelectQuery() 
 	  	{ astq.setBody(exp); q = Query.create(astq); stack.add(q); astq = ast; } 
// 	  <RBRACE>
}


void Bind(Exp stack) : { Expression exp; Exp q; Variable var;}
{
	<BIND> <LPAREN> exp = Expression(stack) <AS> var = Var() <RPAREN> 
	
	{
		q = astq.createBind(exp, var); stack.add(q);
	}
}


// ---- Definitions of each pattern element

void OptionalGraphPattern(Exp stack) : { Exp e; }
{ 
	( <OPTIONAL> | <OPTION> { deprecated("option","optional"); } ) 
  	e = GroupGraphPattern()
  	{ 
  		e= Option.create(e);
  		stack.add(e); 		
  	}
}

void MinusGraphPattern(Exp stack) : { Exp e; }
{ 
	<MINUSP>  e = GroupGraphPattern()
  	{ 
  		e = Minus.create(e);
  		stack.add(e); 		
  	}
}

void NegationGraphPattern(Exp stack) : { Exp e; }
{ 
	 <NOT> 
  	e = GroupGraphPattern()
  	{ 
  		e= Negation.create(e);
  		stack.add(e); 		
  	}
}

void ExistGraphPattern(Exp stack) : { Exp e; }
{ 
	 <EXIST> 
  	e = GroupGraphPattern()
  	{ 
  		e= Exist.create(e);
  		stack.add(e); 		
  	}
}

void ScopeGraphPattern(Exp stack) : { Exp e; }
{ 
	 <SCOPE> 
  	e = GroupGraphPattern()
  	{ 
  		e= Scope.create(e);
  		stack.add(e); 		
  	}
}

void IfThenElse(Exp stack) : { Exp e; Exp e1; Exp e2; Exp e3;}
{ 
	 <IF> 
  	e1 = GroupGraphPattern()
  	
  	<THEN>
  	e2 = GroupGraphPattern()
  	
  	{e3 = null;}
  	
  	(<ELSE>
  		e3 = GroupGraphPattern()
  	)?		
  	  	
  	  {e = IfThenElse.create(e1, e2, e3); stack.add(e);}
  	
}


void ForallGraphPattern(Exp stack) : { Exp e; Exp e1; Exp e2; }
{ 
	 <FORALL> 
  	e1 = GroupGraphPattern()
  	e2 = GroupGraphPattern()
  	
  	{ 
  		e = Forall.create(e1, e2);
  		stack.add(e); 		
  	}
}

void GraphGraphPattern(Exp stack) : 
	{ Atom src; Exp e; Source st; 
	  boolean state = false, leaf = false, rec = false;}
{
	
	 <GRAPH>
	 
  	src = VarOrIRIref(stack) 
  	e = GroupGraphPattern()
  	{ 
  		st =  Source.create(src, e);
  		if (state) { 
  			st.setState(true); 
  			if (leaf) st.setLeaf(true);
  		}
  		if (rec){
  			st.setRec(true);
  		}
  		stack.add(st);
  	}
}

void ServicePattern(Exp stack) : 
	{ Atom src; Exp e; Service st;}
{
	
	 <SERVICE>  (<SILENT>)?
	 
  	src = VarOrIRIref(stack) 
  	e = GroupGraphPattern()
  	{ 
  		st =  Service.create(src, e);
  		stack.add(st);
  	}
}

void ScoreGraphPattern(Exp stack) : { Atom src; Exp e; }
{
  <SCORE> 
  src = VarOrBlankNodeOrIRIref(stack) 
  e = GroupGraphPattern()
  { 
  	astq.setScore(true);
  	e = Score.create(src, e);
  	stack.add(e);
  }
}

// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
void GroupOrUnionGraphPattern(Exp stack) : { Exp temp, res; }
{
	res = GroupGraphPattern()
  	( 
  	  	( <UNION> | <OR> { deprecated("or","union"); } )
  	  	{ 
  	  		temp = res;
      		res =  Or.create();
      		res.add(temp);
  	  	}
    	temp = GroupGraphPattern()  
    	{ res.add(temp); }  
  	)*  
	{ stack.add(res); }
}

void Constraint(Exp stack) : { }
{
  <FILTER> Filter(stack)
  
}


void Filter(Exp stack) : { Expression expression1; Triple triple; }
{
  (   expression1 = BrackettedExpression(stack) 
    | expression1 = BuiltInCall(stack) 
    | expression1 = FunctionCorese(stack)
    | expression1 = FunctionCall(stack) 
  )
  { 
  		if (expression1 != null ) {
	    	triple = astq.createTriple(expression1);
	    	stack.add(triple);    	
	    }
  }
}


// -------- Construct patterns

Exp ConstructTemplate() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples(Exp stack) : {}
{
  (
  	(TriplesSameSubject(stack) | GraphGraphPattern(stack))
  	(<DOT>)? 
  	ConstructTriples(stack)   	
  )?
}


Exp ConstructTemplate2() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples2(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples2(Exp stack) : {}
{
  (
  	TriplesSameSubject(stack) 
  	(<DOT>)? 
  	ConstructTriples2(stack)   	
  )?
}








// -------- Triple lists with property and object lists
void TriplesSameSubject(Exp stack) : { Expression expression1; }
{
  ( LOOKAHEAD(2)
  	expression1 = VarOrTerm(stack)
	stack = PropertyListNotEmpty(expression1, stack)
  |
  	expression1 = TriplesNode(stack)
  	stack = PropertyList(expression1, stack)
 // | stack = tuple(stack)
  )
}


  
Exp PropertyList(Expression expression1, Exp stack) : {}
{  
  ( LOOKAHEAD(2) stack = PropertyListNotEmpty(expression1, stack) ) ?
  { return stack; }
}

Exp PropertyListNotEmpty( Expression expression1, Exp stack) : 
{ ExpressionList v; Atom atom; Expression expression2; Exp e1; Triple triple; int n;}
{ 
  atom = Verb2() 
  { n = stack.size(); }  
  // ObjectList() may fill the stack beyond n in case of [prop ?val] 
  // hence we store the index n to add the triple at n	
  v = ObjectList(stack)
  {
  	for (int i=0;i<v.size();i++) {
      	expression2 = v.get(i);
        //triple = Triple.create(expression1, atom, expression2);
        e1 = astq.createTriple(expression1, atom, expression2);
		//e1 = triple; //.parseGet(parser); //, expression1, atom, expression2);
        if (e1 != null){
        	// add triple at place n (see above for definition of n)
        	stack.add(n++, e1);
        }      
	}
  }
  (
  	<SEMICOLON> 
  	{ stack = PropertyList(expression1, stack); }
  ) ?
  { return stack; }
}

Atom Verb2(): { Atom atom; String[] s; Token t; }
{
  s = PQualifier()
  atom = Verb()
  {
  	if (s[0]!="") { atom.setIsone(true); }
  	if (s[1]!="") { atom.setIsall(true); }
  	if (s[2]!="") { atom.setIsdirect(true); }
  }
 
 // ( LOOKAHEAD(2) 
  //  (
   // 	<LBRACE> t = <INTEGER> <RBRACE> { atom.setIsset(true); } 
    //  	| <LBRACKET> t = <INTEGER> <RBRACKET> 
    //) 
    //{ 
    	//atom.setPath(Integer.parseInt(t.image)); 
  		//atom.setName(atom.getName()); 
  	//} 
  //)?
  
  { return atom; }
}

String[] PQualifier(): { String[] s; String s1, s2, s3; }
{
	{ s1=""; s2=""; s3=""; }
	(
		s1 = One2() ( ( s2 = All2() ( s3 = Direct2() )? ) | ( s3 = Direct2() ( s2 = All2() )? ) )?
	  	| s2 = All2() ( ( s1 = One2() ( s3 = Direct2() )? ) | ( s3 = Direct2() ( s1 = One2() )? ) )? 
	  	| ( s3 = Direct2() ( ( s1 = One2() ( s2 = All2() )? ) | ( s2 = All2() ( s1 = One2() )? ) )? )?
	)
	{ 
		s = new String[3];
		s[0] = s1; // one
		s[1] = s2; // all
		s[2] = s3; // direct
	}
  	{ return s; }
}

String One2(): { Token t; }
{
	( t = <ONE2> | t = <CURRENT> )
	{ return t.image; }
}

String All2(): { Token t; }
{
	t = <ALL2>
	{ return t.image; }
}

String Direct2(): { Token t; }
{
	t = <DIRECT2>
	{ return t.image; }
}

ExpressionList ObjectList(Exp stack): { Expression expression1; ExpressionList v; }
{
  { v = new ExpressionList(); }
  
  expression1 = GraphNode(stack)
  { v.add(expression1); }
  
  ( 
  	 <COMMA> 
     expression1 = GraphNode(stack)
     { v.add(expression1); }
  ) *
  
  { return v; }
}

Atom Verb() : { Atom atom; }
{
  ( 
    atom = PropertyVarOrIRIref() 
    | <KW_A> { atom = astq.createQName(RDFS.qrdftype); }
  )
  { return atom; }
}


Atom PropertyVarOrIRIref(): { Atom atom; Token t1; Variable var; Constant cst; String temp; }
{
  
  ( 
      atom = StdProperty()
      
    | atom = Var()
    
 
  )
  
  
  { return atom; }
}




Atom StdProperty(): {Variable var; Constant cst;  Expression exp;}
{
  	
  	  exp = RegExp()
      
      { cst = astq.createProperty(exp);
      } 
      
      ( 
      	<COLON2> 
      	var = Var() 
      	{ 
      		cst.setVar(var); 
      	} 
      )? 
      
      { return cst; }
      
}


Expression RegExp():{Token t; String s; Expression exp;}
{

(
	   t = <XPATH>   <LPAREN> s = String() <RPAREN>
	   
	  { exp = astq.createFunction(t.image, astq.createConstant(s, null, null)); }  |

	  exp = AddRegExp()   | 
	
	(
		t = <INV> | t = <SHORT> | t = <SHORTALL> | t = <DEPTH> | t = <BREADTH>)
	
	  	exp = RegExp()  { exp = astq.createOperator(t.image, exp); }
)
	
	{return exp;}
}



Expression AddRegExp():{Token t; Expression exp1, exp2;}
{
    exp1 = MultRegExp() 
    
    ( t = <BAR>   exp2 = MultRegExp() 
    
    {exp1 = astq.createConditionalOrExpression(t.image, exp1, exp2); } 
    
    ) *
    
    { return exp1;}

}


Expression MultRegExp():{Token t; Expression exp1, exp2;}
{

	exp1 = UnaryRegExp() 
	
	( t = <SLASH>  exp2 = UnaryRegExp() 
	
	  {exp1 = astq.createMultiplicativeExpression(t.image, exp1, exp2); } 
		
	) *

	{ return exp1;}

}


Expression UnaryRegExp():{Token t, t1, t2; Expression exp; Token ope; String s1, s2;}
{
(
	t = <BANG>   
	
	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp); }
	
	
|   t = <BEGIN_WITH>	

	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp);  }
	
//	( ope = OpeRegExp()     { exp = astq.createOperator(ope.image, exp); }  )  ? 

	
|	exp = PrimaryRegExp()  

    (  ope = OpeRegExp()     { exp = astq.createOperator(ope.image, exp); }   
    
    |
        
    
		<LBRACE>  
		  { s1 = null; s2 = null; }
		(
		  t1 = <INTEGER>  {s1 = t1.image; s2 = s1; }  (<COMMA> {s2 = null;} (  t2 = <INTEGER>  {s2 = t2.image;} )? )? 
		  
		  |
		  
   		  <COMMA>    t2 = <INTEGER>  {s2 = t2.image;}
   		)
   		<RBRACE> 
   		
   		{ exp = astq.createOperator(s1, s2, exp); }
    
    )  ? 
)

{ return exp;}

}





Token OpeRegExp() : {Token ope;}
{

(	ope = <STAR>
|	ope = <PLUS>
|	ope = <QM>
)

{ return ope; }

}


Expression PrimaryRegExp():{Expression exp, test; Exp stack; String t; Constant cst;}
{
	( 
		exp = IRIrefConst() 
		
		|	
	
		<LPAREN> exp = AddRegExp() <RPAREN>
	) 
	
	
	( 	LOOKAHEAD(2)
		<AT> 
		(
		// filter
		<LBRACKET> 
		  { stack = BasicGraphPattern.create(); }
		  test = Expression(stack) 
		  {exp = astq.setRegexTest(exp, test);} 
		<RBRACKET> 	
		
		|
		// pattern
		//<LBRACE> 
		  stack = GroupGraphPattern()
		  
		  {test = astq.createExist(stack, false);
		   exp = astq.setRegexTest(exp, test);}
		  
		//<LBRACE>
		)	
	) ?   
	
	
	{ return exp; }

}



Token Soper(): { Token t; }
{
  ( 
    t = <EQ> | t = <NE> 
  | t = <LT> | t = <GT>
  | t = <LE> | t = <GE>
  | t = <EQ2> | t = <NE2> 
  | t = <TILDE> 
 // | t = <IN> 
  | t = <BEGIN_WITH>
  )
  { return t; }
}

Token Toper(): { Token t; }
{
  ( t = <STRICT_SPEC> | t = <SPEC> | t = <SAME>
  | t = <GENERALISATION> | t = <STRICT_GENERALISATION> )
  { return t; }  
}

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples

Expression TriplesNode(Exp stack) : { Expression expression1; }
{
  ( 
  	expression1 = Collection(stack) 
  	| expression1 = BlankNodePropertyList(stack) 
  )
  { return expression1; }
}

Expression BlankNodePropertyList(Exp stack) : { Expression expression1; }
{
  { 
  	// [ :p ?y ]
  	expression1 = astq.newBlankNode();
  }
  <LBRACKET>
  stack = PropertyListNotEmpty(expression1, stack)    
  <RBRACKET>
  { return expression1; }
}

// ------- RDF collections
/**
* see: http://www.w3.org/TR/rdf-sparql-query/#collections
*
* exemple 1: The collection ( 1 ?x 2 3 ) generates 8 triples:
* _:b0 rdf:first 1		_:b0 rdf:rest _:b1
* _:b1 rdf:first ?x		_:b1 rdf:rest _:b2
* _:b2 rdf:first 2		_:b2 rdf:rest _:b3
* _:b3 rdf:first 3		_:b3 rdf:rest rdf:nil
*
* exemple 2: The collection ( ?x [ :p 'v' ] ( 3 ) ) generates 9 triples:
* _:b0 rdf:first x		_:b0 rdf:rest _:b1
* _:b1 rdf:first _:b2	_:b1 rdf:rest _:b3		_:b2 :p 'v'
* _:b3 rdf:first _:b4	_:b3 rdf:rest rdf:nil	_:b4 rdf:first 3	_:b4 rdf:rest rdf:nil
*
*/
Expression Collection(Exp stack) : 
{ 
  ArrayList<Expression> list;
  Expression node;
  RDFList rlist;
  boolean close;
}
{
	{
		close = true;
		list = new ArrayList<Expression>();
	}
	
	//  @( ) means a sublist (query list without rdf:nil at the end)
	
	( 
		<AT> { close = false; }  
	) ?
	
  	<LPAREN>
  	(
  		node = GraphNode(stack)
  		{
  			list.add(node);
  		}   
  	) +
  	<RPAREN>
  	{ 
  	    rlist = astq.createRDFList(list, close);
  		stack.add(rlist);
  		return rlist.head(); 
  	}
}





Expression Collection2(Exp stack) : 
{ Expression graphNodeExpression, firstExpression, lastExpression, bnExpression; 
  Exp tripleGenerated, finalCollection; boolean subList, contains;}
{
	{
		lastExpression = null;
		firstExpression = null;
		finalCollection = new And();
		subList = false;
		contains = false;
	}
	
	//  @( ) means a sublist (query list without rdf:nil at the end)
	
	( 
		<AT> { subList = true; }  
	) ?
	
  	<LPAREN>
  	(
  		graphNodeExpression = GraphNode(stack)
  		{
  			bnExpression = astq.newBlankNode();
  			
  			if (firstExpression == null) {
  				firstExpression = bnExpression;
  			}
  			
  			if (lastExpression != null) {  				
  				tripleGenerated = astq.generateRest(lastExpression, bnExpression);
  				finalCollection.add(tripleGenerated);
  			}
  			
  			tripleGenerated = astq.generateFirst(bnExpression, graphNodeExpression);
  			finalCollection.add(tripleGenerated);
  			
  			lastExpression = bnExpression;
  		}   
  	) +
  	<RPAREN>
  	{ 
  		if (! subList) {
  			tripleGenerated = astq.generateRest(lastExpression, astq.createQName(RDFS.qrdfNil));
   			finalCollection.add(tripleGenerated);
  		}
  		//System.out.println("sparql_corese.jj - Collection - "+finalCollection.toSparql());  
  		stack.add(finalCollection);
  		return firstExpression; 
  	}
}

// -------- Nodes in a graph pattern or template

Expression GraphNode(Exp stack) : { Expression expression1; }
{
  (   LOOKAHEAD(2)
  	  expression1 = VarOrTerm(stack) 
  	| expression1 = TriplesNode(stack)   	
  )
  { return expression1; }
}

Atom VarOrTerm(Exp stack) : { Atom expression1; }
{
  ( expression1 = Var() | expression1 = GraphTerm(stack) )
  { return expression1; }
}

Atom VarOrBlankNodeOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
    a = Var() { s = a.getName(); } 
    | a = BlankNode(stack) { s = a.getName(); } 
    | a = IRIrefConst() 
  )
  { return a; }
}

Atom VarOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
      a = Var() 
    | a = IRIrefConst() 
  )
  { return a; }
}


Variable Var() : { Token t1; Variable res; String s; boolean isPath = false;}
{
  ( t1 = <VAR1> { s = t1.image; } | 
    t1 = <VAR2> { s = "?"+(t1.image).substring(1,(t1.image).length()); isPath = true;} ) 
  { res = ASTQuery.createVariable(s, astq); res.setPath(isPath);}
  
  { return res; }
}

Atom GraphTerm(Exp stack) : { Constant cst; String s; Token t1; Variable var; Atom a; }
{
  (
  	( 
  	s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME> 
  		{ cst = astq.createQName(t1.image);  }
    	( 
 	   	<COLON2> 
 	   	var = Var() 
 		{ cst.setVar(var); } 
 	    )?
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image); }
  	| cst = RDFLiteral() 
  	| // ( <MINUS> | <PLUS> )? 
  	  cst = NumericLiteral()
  	| cst = BooleanLiteral()   
  	| 
 // 		t1 = <NIL> 
  		t1 = <LPAREN>  <RPAREN> 
  	{ cst = astq.createQName(RDFS.qrdfNil); }  
  	) { a = cst; }
  	| a = BlankNode(stack) 
  )
  { return a; }
}

// -------- Constraint syntax

Expression Expression(Exp stack) : { Expression expression1; }
{	
  expression1 = ConditionalOrExpression(stack)
  { return expression1; }
}

Expression ConditionalOrExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ConditionalAndExpression(stack)
  ( 
    t1 = <SC_OR> 
    expression2 = ConditionalAndExpression(stack) 
    { expression1 = astq.createConditionalOrExpression(t1.image, expression1, expression2); }
  )* 
  { return expression1; }  
}

Expression ConditionalAndExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ValueLogical(stack)
  ( 
    t1 = <SC_AND> 
    expression2 = ValueLogical(stack) 
    { expression1 = astq.createConditionalAndExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression ValueLogical(Exp stack) : { Expression expression1; }
{
  expression1 = RelationalExpression(stack)
  { return expression1; }
}

Expression RelationalExpression(Exp stack) : { Token t1; Expression expression1, expression2; ExpressionList el; boolean not = false;}
{
  expression1 = NumericExpression(stack)
  ( 
    (   
        t1 = Soper() expression2 = NumericExpression(stack)
      | t1 = Toper() expression2 = NumericExpression(stack)  
      |  (<NOT> {not = true;} )? 
        t1 = <IN>    el = ArgList(stack) {expression2 = astq.createList(el);}
    ) 
    
    { expression1 = astq.createRelationalExpression(t1.image, expression1, expression2); 
    if (not){
    	expression1 = astq.negation(expression1);
    	}
    }
  )?
  { return expression1; }
}




Expression NumericExpression (Exp stack) : { Expression expression1; }
{
  expression1 = AdditiveExpression(stack)
  { return expression1; }
}

Expression AdditiveExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = MultiplicativeExpression(stack)
  ( 
  	  t1 = <PLUS> expression2 = MultiplicativeExpression(stack) 
  	  { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
    | t1 = <MINUS> expression2 = MultiplicativeExpression(stack) 
      { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression MultiplicativeExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = UnaryExpression(stack)
  ( 
    ( 
    	t1 = <STAR> expression2 = UnaryExpression(stack) 
      | t1 = <SLASH> expression2 = UnaryExpression(stack) 
    ) 
    { expression1 = astq.createMultiplicativeExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
//   | <REM> UnaryExpression()
}

Expression UnaryExpression(Exp stack) : { Token t1; Expression expression1; }
{
  (   t1 = <BANG> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <PLUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <MINUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | expression1 = PrimaryExpression(stack) 
  )
  { return expression1; }
}

Expression BuiltInCall(Exp stack) : { Expression expression1, expression2; Variable var1; Token t1; Term term; }
{
  (
    ( ( 
        t1 = <STR> | 
        t1 = <DTYPE> | t1 = <LANG> | t1 = <IS_IRI> | t1 = <IS_URI> | 
        t1 = <IS_BLANK> | t1 = <IS_LITERAL> ) 
    	<LPAREN> expression1 = Expression(stack) <RPAREN> 
      { term = astq.createFunction(t1.image, expression1); } 
    )
    | t1 = <BOUND> <LPAREN> var1 = Var() <RPAREN> 
      { term = astq.createFunction(t1.image, var1); } 
    | t1 = <LANGMATCHES> <LPAREN> expression1 = Expression(stack) <COMMA> expression2 = Expression(stack) <RPAREN>
      { term =  astq.createFunction(t1.image, expression1); 
        term.add(expression2); } 
    | term = RegexExpression(stack)
    | term = exists()
  )
  { return term; }
}


Term exists() : {Exp exp; Term term; boolean neg;}
{
	{neg = false;}
	
	(<NOT> {neg = true;})?
	 <EXIST> exp = GroupGraphPattern()
	{
		term = astq.createExist(exp, neg);
		return term;
	}
}


Term RegexExpression(Exp stack): { Term term; Token t; Expression expression1, expression2; }
{
  t = <REGEX> 
  <LPAREN>
      expression1 = Expression(stack) <COMMA> expression2 = Expression(stack)
      { term = astq.createFunction(t.image, expression1);
      term.add(expression2); }
      ( <COMMA> expression2 = Expression(stack) { term.add(expression2); } ) ?
  <RPAREN>
  { return term; }
}

Term FunctionCorese(Exp stack): { Token t; Term term; ExpressionList v; Constant cst; }
{	
	// distance namespace isMulti sqrt depth cardinality isuri occurence
  (
	( t = <SIMPLE_STRING> | t = <DISTANCE> | t = <SCORE> | t = <COUNT> | t = <XPATH>
	// | t = <DISTINCT> 
	)
	v = ArgList(stack)
	{ 
		term = astq.createFunction(t.image, v); 
	}
  )
  { return term; }
}

Term FunctionCall(Exp stack) : { Term term1;  String s; ExpressionList v; }
{
  s = IRIref() 
  v = ArgList(stack)
  { 
  	term1 = astq.createFunction(s, v); 
  }
  { return term1; }
}
// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

Expression IRIrefOrFunction(Exp stack) : { String s1; ExpressionList v; Term term; Expression expression;  Constant cst;}
{
  cst = IRIrefConst() {expression = cst;}
  ( 
    v = ArgList(stack)
    { 
    	term = astq.createFunction(cst, v); 
	  	expression = term;
    } 
  )?
  { return expression; } 
}

ExpressionList ArgList(Exp stack) : { ExpressionList v; Token t; Expression expression1; String str;}
{
  { 
  	// Vector containing either Expression or Variable
  	v = new ExpressionList();
  }
  
  ( 
  
 //   <NIL> |
  //  <LPAREN>  <RPAREN> 
   
   
 	 
  	<LPAREN> 
  	
	  	(<DISTINCT> {v.setDistinct(true);}) ? 
	  	
	  	(
		  	<STAR> 
		  	
		  	|
		   
		              expression1 = Arg(stack) { v.add(expression1); }
		              
		    ( <COMMA> expression1 = Arg(stack) { v.add(expression1); } )*
		    
	    ) ?
	    
    ( <SEMICOLON>  <SEPARATOR>  <EQ>  str = String() { v.setSeparator(str); } ) ?
    
    <RPAREN>
    
  )
  { return v; }
}


Expression Arg(Exp stack) : {Expression exp;}
{
	(
		exp = Expression(stack)  | exp = Array(stack)
	)
	{
		return exp;
	}
}



// fun(?x, [1 2 3])
// return a blank that contains an array (aka pointer !)
Expression Array(Exp stack) : {Expression exp; ExpressionList array;}
{
	{ 
  		array = new ExpressionList(); 
    }
  
	<LBRACKET> 
		          exp = Arg(stack) { array.add(exp); }
		( <COMMA> exp = Arg(stack) { array.add(exp); } ) * 
		
	<RBRACKET>
		
	{
		exp = astq.newArray(array);
		return exp;
	}
}



Expression BrackettedExpression(Exp stack) : { Expression expression1; }
{
	<LPAREN> expression1 = Expression(stack) <RPAREN>
	{ 
		return expression1; 
	}
}

Expression PrimaryExpression(Exp stack) : { Expression expression1; }
{
  ( 
   expression1 = BrackettedExpression(stack)	// Expression
   | expression1 = BuiltInCall(stack)		// Expression
   | expression1 = FunctionCorese(stack)	// Term
   | expression1 = Var()				// Variable
   | expression1 = RDFLiteral()			// Constant
   | expression1 = NumericLiteral()		// Constant
   | expression1 = BooleanLiteral()		// Constant
   | expression1 = BlankNode(stack) 			// Constant
   | expression1 = IRIrefOrFunction(stack)   // Expression
   // NOT  |  VarOrTerm()        
   // Because of IRIrefOrFunction
  )
  { return expression1; }
}

Constant NumericLiteral() : { Token t; String datatype; }
{
   ( t = <INTEGER> { datatype = RDFS.qxsdInteger; } 
   | t = <DECIMAL> { datatype = RDFS.qxsdDecimal; } 
   | t = <DOUBLE>  { datatype = RDFS.qxsdDouble; } )
   { return astq.createConstant(t.image, datatype); }
}

Constant RDFLiteral() : { Constant res; String iriref, s, lang; Token t; }
{
  s = String()
  { iriref = null; lang=null; }
  (
    t = <LANGTAG> { lang = t.image.substring(1,t.image.length()); }
    | ( t = <DATATYPE> iriref = IRIref() )  
  )?
  { res = astq.createConstant(s, iriref, lang); }
  { return res; }
}

Constant BooleanLiteral() : { Token t1, t2; Constant cst; String iriref, lang;}
{
  ( t1 = <TRUE> | t1 = <FALSE> )  
  { iriref = RDFS.qxsdBoolean; lang=null; }
  
  { 
  	cst = astq.createConstant(t1.image.toLowerCase(), iriref, lang);
  	return cst; 
  } 
}

String String() : { Token t; }
{
  (  t = <STRING_LITERAL1>
  |  t = <STRING_LITERAL2>
  |  t = <STRING_LITERAL_LONG1>
  |  t = <STRING_LITERAL_LONG2>
  )
  { return t.image; }
}

String IRIref() : { String res; }
{
   ( res = Q_IRI_ref() 
   | res = QName() )
   { return res; }
}


Constant IRIrefConst() : { String res; Constant cst;}
{
   ( res = Q_IRI_ref() {cst = astq.createURI(res);}
   | res = QName()     {cst = astq.createQName(res);}
   )
   { return cst; }
}



String QName(): { Token t; }
{
  ( t = <QNAME> | t = <QNAME_NS> )
  { return t.image; }
}

Variable BlankNode(Exp stack): { Token t; Variable v; }
{
  ( 
 	t = <BLANK_NODE_LABEL> 
	{
 		// check if the blank node is already in the table
  		v = astq.newBlankNode(stack, t.image);
		
  	}
  	| t = <ANON>   	
  	{ 
  		// create a new blank node
  		v = astq.newBlankNode(); 
  	}
  )
  { 
  	return v; 
  }
}


String Q_IRI_ref() : { Token t; String s; }
{
   	t = <Q_IRIref>
	{ 
		s = t.image;
      	s = s.substring(1,s.length()-1); 
      	s = astq.defURI(s);
   	  	return s; 
   	}
}


// ------------------------------------------
// Tokens
// ------------------------------------------

TOKEN_MGR_DECLS:{
		
	void CommonTokenAction(Token token) {
		//System.out.println(token+" ");
	}
}

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <Q_IRIref: "<" (~[">","<","\u0000"-"\u0020"])* ">" > 
   
| <QNAME_NS: (<NCNAME_PREFIX>)? ":" >
| <QNAME: (<NCNAME_PREFIX>)? ":" (<NCNAME>)? >
| <BLANK_NODE_LABEL: "_:" <NCNAME> >
//|  <BLANK_NODE_ID: "_!:" <NCNAME> >

| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
//| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
| <LANGTAG: <AT> (<A2Z>)+(("-"|":") (<A2ZN>)+)* >	// to accept @get:lang
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { 

	<KW_A: "a" > 
|	<INV: "i" >
|	<SHORT: "s" >
|	<SHORTALL: "sa" >
|	<DEPTH: "d" >
|   <BREADTH: "b">


} // Before HEX rule!

TOKEN [IGNORE_CASE] :
{
// Prologue
   < BASE: "base" >
| < PREFIX: "prefix" >

// Result forms
| < SELECT: "select" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < ASK: "ask" >

| < DISTINCT: "distinct" >
| < SEPARATOR: "separator" >

| < REDUCED: "reduced" >
| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
| < ANY: "any" >
| < RELAX: "relax" >

| < ASC: "asc" >
| < DESC: "desc" >

// Dataset
| < NAMED: "named" >
| < FROM: "from" >

// Graph pattern operators 
| < WHERE: "where" >
| < AND: "and" >
| < GRAPH: "graph" >
| < SERVICE: "service" >
| < REC : "rec" >
| < STATE : "state" >
| < LEAF : "leaf" >
| < OPTIONAL: "optional" >
| < UNION: "union" >
| < MINUSP: "minus" >
| < NOT: "not">
| < SCOPE: "scope">
| < FORALL: "forall">
| < IF: "iff">
| < THEN: "then">
| < ELSE: "else">
| < EXIST: "exists">
| < FILTER: "filter" >


// UPDATE

| < LOAD: "load">
| < CLEAR: "clear">
| < DROP: "drop">
| < CREATE: "create">
| < ADD: "add" >
| < TO: "to"> 
| < MOVE: "move">
| < COPY: "copy">
| < INSERT: "insert">
| < DELETE: "delete">
| < WITH: "with">
| < USING: "using">
| < DEFAUT: "default">
| < ALL: "all">
| < INTO: "into">
| < SILENT: "silent">
| < DATA: "data">


// Expression operators
| < BOUND: "bound" >
| < STR: "str" >
// |  < URI:         "uri" >
| < DTYPE: "datatype" >
| < LANG: "lang" >
| < LANGMATCHES: "langmatches" >
//|  < IS_IRI:      ("isIRI"|"isURI") >
| < IS_URI: "isURI" >
| < IS_IRI: "isIRI" >
| < IS_BLANK: "isBlank" >
| < IS_LITERAL: "isLiteral" >
| < REGEX: "regex" >

| <TRUE: "true" >
| <FALSE: "false" >
}

// -------------------------------------------------
// Rajouts pour CORESE
// -------------------------------------------------

TOKEN [IGNORE_CASE] :
{
  <ONE: "one" >
| <S_MORE: "more" >
| <LIST: "list" >
| <MERGE: "merge" >
| <DISPLAY: "display" >
| <PRAGMA: "pragma" >
| <D_RDF: "rdf" >
| <D_JSON: "json" >
| <D_FLAT: "flat" >
| <D_ASQUERY: "asquery" >
| <D_XML: "xml" >
| <D_BLANK: "blank" >
//| <D_TABLE: "table" >
| <THRESHOLD: "threshold" >
| <RESULT: "result" >
| <PROJECTION: "projection" >
| <GROUP: "group" >
| <HAVING: "having" >
| <BINDINGS: "bindings">
| <BIND: "bind">
| <UNDEF: "undef">
| <COUNT: "count" >
| <SOURCE: "source" >
| <SCORE: "score" >
| <AS: "as" >
| <SORT: "sort" >
| <REVERSE: "reverse" >
| <OR: "or" >
| <OPTION: "option" >
| <SORTED: "sorted" >
| <ALL2: "all::" >
| <CURRENT: "current::" >
| <ONE2: "one::">
| <DIRECT2: "direct::" >
| <COLON2: "::" >
| <DISTANCE: "distance">
| <DEBUG: "debug">
| <CHECK: "check">
| <NOSORT: "nosort">
| <TUPLE: "tuple">
| <XPATH: "xpath">
}

TOKEN [IGNORE_CASE] :
{
  <IN: "in">
}

TOKEN :
{
  <EQ2: "==">
| <NE2: "!==">
| <BEGIN_WITH: "^">
| <STRICT_SPEC: "<:">
| <SPEC: "<=:">
| <SAME: "=:">
| <GENERALISATION: ">=:">
| <STRICT_GENERALISATION: ">:">
| <EQ_LANG: "~=">
}

TOKEN [IGNORE_CASE] :
{
  <SIMPLE_STRING: <NCNAME> >  
}

// -------------------------------------------------

TOKEN :
{
//   < INTEGER: (["-","+"])? <DIGITS> >
   < INTEGER: (["-"])? <DIGITS> >
|
   < DECIMAL: (["-"])? (<DIGITS>)+ "." (<DIGITS>)* | "." (<DIGITS>)+ >
      // Required exponent.
| < DOUBLE:
      (["-"])?
      (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
      | "." (["0"-"9"])+ (<EXPONENT>)
      | (["0"-"9"])+ <EXPONENT>
      >
//| < FLOATING_POINT:
//      //(["+","-"])?
//      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
//      | "." (["0"-"9"])+ (<EXPONENT>)?
//      | (["0"-"9"])+ <EXPONENT>
//      >
   // Optional exponent.
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ("t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'")>

| < STRING_LITERAL1:
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
| < STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ~["'","\\"] | <ECHAR> | ("'" ~["'"]) | ("''" ~["'"]))*
     <QUOTE_3S> >
| < STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ~["\"","\\"] | <ECHAR> | ("\"" ~["\""]) | ("\"\"" ~["\""]))*
     <QUOTE_3D> >
| < DIGITS: (["0"-"9"])+>
| <HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >

// I don't know why white space is needed to be included here but not ANON
//| <NIL: <LPAREN> (<WS>)* <RPAREN> >

| < LBRACE: "{" >
| < RBRACE: "}" >

| < LBRACKET: "[" >
| < RBRACKET: "]" >
// (<WS>)* is not needed but is in NIL
| < ANON: <LBRACKET> (<WS>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Operator

TOKEN :
{
  < EQ: "=" >
| < NE: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" > // Maybe: | "=>" >
| < GE: ">=" > // Maybe: | "=<" >

| < BANG: "!" >
| <TILDE: "~">
| < COLON: ":" >

| < SC_OR: "||" >
| < SC_AND: "&&" >

| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < QM: "?" >
| < BAR: "|" >


//| < AMP: "&" >
//| < REM: "%" >

| < DATATYPE: "^^">
| < AT: "@">
}

// See XML chars.txt for notes

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#NCCHAR1p:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFFFD"] >
          // [#x10000-#xEFFFF]
|
  <#NCCHAR1: <NCCHAR1p> | "_" >

// No trailing DOTs in qnames.
|
  // #NCCHAR without "."
  <#NCCHAR: (<NCCHAR1> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // NCNAME but no leading "_", no trailing ".", can have dot inside prefix name.
  <#NCNAME_PREFIX: <NCCHAR1p> ((<NCCHAR>|".")* <NCCHAR>)? >
|
  // With a leading "_", no dot at end of local name.
  <#NCNAME: <NCCHAR1> ((<NCCHAR>|".")* <NCCHAR>)? >
|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <NCCHAR1> | ["0"-"9"] )
             ( <NCCHAR1> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
}

/*
 * (c) Copyright 2004, 2005 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
